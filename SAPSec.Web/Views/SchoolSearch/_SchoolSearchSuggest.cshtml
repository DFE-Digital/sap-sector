@using SAPSec.Web.ViewModels
<script type="text/javascript" src="/js/accessible-autocomplete.min.js" asp-append-version="true"></script>
<script add-nonce="true">
  // Sending requests to a server means that when the autocomplete has no
  // result, it may not be because there are no results, but because these
  // results are being fetched, or because an error happened. We can use the
  // function for internationalizing the 'No results found' message to
  // provide a little more context to users.
  //
  // It'll rely on a `status` variable updated by the wrappers of the
  // function making the request (see thereafter)
  let status;

  function tNoResults() {
    if (status === 'loading') {
      return 'Loading suggestions...'
    } else if (status === 'error') {
      return 'Sorry, an error occurred'
    } else {
      return 'No results found'
    }
  }

  // We'll wrap that function multiple times, each enhancing the previous
  // wrapping to handle the different behaviors necessary to
  // appropriately coordinate requests to the server and display feedback to
  // users
  const makeRequest =
    // Wrapping everything is the error handling to make sure it catches
    // errors from any of the other wrappers
    trackErrors(
      // Next up is tracking whether we're loading new results
      trackLoading(
        // To avoid overloading the server with potentially costly requests
        // as well as avoid wasting bandwidth while users are typing, we'll
        // only send requests a little bit after they stop typing
        debounce(
          // Finally, we want to cancel requests that are already sent, so
          // only the results of the last one update the UI This is the role
          // of the next two wrappers
          abortExisting(
            // That last one is for demo only, to simulate server behaviors
            // (latency, errors, filtering) on the client
            requestSuggestions
          ),
          250
        )
      )
    );

  // We can then use the function we built and adapt it to the autocomplete
  // API encapsulating the adjustments specific to rendering the 'No result
  // found' message
  function source(query, populateResults) {
    // Start by clearing the results to ensure a loading message
    // shows when the query gets updated after results have loaded
    populateResults([])

    makeRequest(query)
      // Only update the results if an actual array of options gets returned
      // allowing for `makeRequest` to avoid making updates to results being
      // already displayed by resolving to `undefined`, like when we're
      // aborting requests
      .then(options => options && populateResults(options))
      // In case of errors, we need to clear the results, so the accessible
      // autocomplete shows its 'No result found'
      .catch(_ => populateResults([]))
  }

  // And finally, we can set up our accessible autocomplete
  const element = document.querySelector('.school-search-suggester-wrapper')
  const id = '@nameof(SchoolSearchQueryViewModel.Query)'

  // Find and remove the fallback input before initializing autocomplete
  const fallbackInput = element.querySelector('input[data-fallback-input="true"]');
  const savedValue = fallbackInput ? fallbackInput.value : '';
  const hasError = fallbackInput ? fallbackInput.classList.contains('govuk-input--error') : false;

  if (fallbackInput) {
    fallbackInput.remove();
  }

  accessibleAutocomplete({
    element: element,
    id: id,
    name: id,
    source: source,
    tNoResults: tNoResults,
    defaultValue: savedValue,
    menuAttributes: {
      "aria-labelledby": id
    },
    inputClasses: "govuk-input-autocomplete"
  })

  // Apply error styling if needed
  const autoCompleteInput = element.querySelector('input');

  if (hasError) {
    if (autoCompleteInput) {
      autoCompleteInput.classList.add('govuk-input--error');
    }
  }

  window.addEventListener('pageshow', function(event) {
    if (event.persisted) {
      // Clear the autocomplete input
      if (autoCompleteInput) {
        autoCompleteInput.value = '';
      }

      // Clear the fallback input if it exists
      if (fallbackInput) {
        fallbackInput.value = '';
      }
    }
  });

  const SERVER_LATENCY = 200;

  function requestSuggestions(query) {
      return new Promise(resolve => {
        return  setTimeout(async () => {
          const suggestions = await fetch(`/school/suggest?queryPart=${encodeURIComponent(query)}`)
            .then((response) => response.json())
            .then((response) => {
              return response;
            })

          resolve(suggestions)
        }, SERVER_LATENCY)
      })
  }

  // Debouncing limits the number of requests being sent
  // but does not guarantee the order in which the responses come in
  // Due to network and server latency, a response to an earlier request
  // may come back after a response to a later request
  // This keeps track of the AbortController of the last request sent
  // so it can be canceled before sending a new one
  let abortController;

  function abortExisting(fn) {
    return function (...args) {
      if (abortController) {
        abortController.abort();
      }

      abortController = new AbortController();

      return fn(...args, {signal: abortController.signal})
        .then(result => {
          abortController = null;
          return result;
        }, error => {
          // Aborting requests will lead to `fetch` rejecting with an
          // `AbortError` In that situation, that's something we expect, so
          // we don't want to show a message to users
          if (error.name !== 'AbortError') {
            abortController = null;
            throw error;
          }
        })
    }
  }

  // Debounce the given function so it only gets executed after a specific delay
  function debounce(fn, wait) {
    let timeout
    return function (...args) {
      return new Promise(resolve => {
        clearTimeout(timeout)

        const later = function () {
          timeout = null
          resolve(fn(...args))
        }
        timeout = setTimeout(later, wait)
      })
    }
  }

  // Tracks the loading state so we can adapt the message being displayed to the user
  function trackLoading(fn) {
    return function (...args) {
      status = 'loading';
      return fn(...args)
        .then(result => {
          status = null;
          return result
        }, error => {
          status = null;
          throw error
        })
    }
  }

  // In a similar fashion, we can track errors happening, which will adjust the message
  function trackErrors(fn) {
    return function (...args) {
      return fn(...args)
        .catch(error => {
          status = 'error'
          throw error
        })
    }
  }
</script>